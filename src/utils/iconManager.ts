/**
 * Icon Manager - D2-Guardian-Forge
 * 
 * Utilities for managing icon uploads and creating PRs
 */

import { ICONS, type IconCategory } from './iconUtils';

export interface IconChange {
  category: string;
  name: string;
  oldPath: string;
  newFile: File;
  previewUrl: string;
}

export interface IconChangeMetadata {
  category: string;
  name: string;
  fileName: string;
  path: string;
  timestamp: number;
}

/**
 * Get all icons grouped by category
 * 
 * @returns Record of categories with arrays of icon objects containing name, hash, and path
 * 
 * @example
 * ```ts
 * const icons = getAllIcons();
 * // { classes: [{ name: 'Titan', hash: 3111577790, path: 'icons/classes/Titan.png' }, ...], ... }
 * ```
 */
export function getAllIcons(): Record<string, Array<{ name: string; hash: number; path: string }>> {
  const result: Record<string, Array<{ name: string; hash: number; path: string }>> = {};
  
  Object.keys(ICONS).forEach(category => {
    if (category === 'default') return;
    
    const categoryData = ICONS[category as IconCategory] as Record<string, number>;
    result[category] = Object.entries(categoryData).map(([name, hash]) => ({
      name,
      hash,
      path: `icons/${category}/${name}.png`
    }));
  });
  
  return result;
}

/**
 * Prepare icon changes for submission
 * 
 * @param changes - Array of icon changes to prepare
 * @returns Blob containing metadata about the changes (not used in current implementation)
 * @deprecated This function is not used in the current implementation
 */
export async function prepareIconChanges(changes: IconChange[]): Promise<Blob> {
  // This function is kept for backward compatibility but is not used
  // The downloadIconChanges function is used instead
  const metadata: IconChangeMetadata[] = changes.map((change) => ({
    category: change.category,
    name: change.name,
    fileName: `${change.name}.png`,
    path: `public/icons/${change.category}/${change.name}.png`,
    timestamp: Date.now()
  }));
  
  const blob = new Blob([JSON.stringify({
    metadata,
    fileCount: changes.length,
    timestamp: Date.now()
  })], { type: 'application/json' });
  
  return blob;
}

/**
 * Download icon changes as a JSON file for manual processing
 * This is a fallback when the API is not available
 * 
 * @param changes - Array of icon changes to download
 * @returns Promise that resolves when download is complete
 * 
 * @example
 * ```ts
 * await downloadIconChanges(iconChanges);
 * // Downloads: icon-changes-1735219200000.json
 * ```
 */
export async function downloadIconChanges(changes: IconChange[]): Promise<void> {
  const changeData: {
    changes: IconChangeMetadata[];
    files: { [key: string]: string };
  } = {
    changes: changes.map(change => ({
      category: change.category,
      name: change.name,
      fileName: `${change.name}.png`,
      path: `public/icons/${change.category}/${change.name}.png`,
      timestamp: Date.now()
    })),
    files: {}
  };
  
  // Convert files to base64
  for (let i = 0; i < changes.length; i++) {
    const change = changes[i];
    const arrayBuffer = await change.newFile.arrayBuffer();
    const base64 = btoa(
      new Uint8Array(arrayBuffer)
        .reduce((data, byte) => data + String.fromCharCode(byte), '')
    );
    changeData.files[`file_${i}`] = base64;
  }
  
  // Create and download JSON file
  const json = JSON.stringify(changeData, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = `icon-changes-${Date.now()}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Generate PR description for icon changes
 * 
 * @param changes - Array of icon changes to document
 * @returns Markdown-formatted PR description
 */
export function generatePRDescription(changes: IconChange[]): string {
  let description = `# Icon Updates\n\n`;
  description += `This PR updates ${changes.length} icon(s) from the Icon Editor.\n\n`;
  description += `## Changed Icons\n\n`;
  
  const groupedChanges = changes.reduce((acc, change) => {
    if (!acc[change.category]) {
      acc[change.category] = [];
    }
    acc[change.category].push(change);
    return acc;
  }, {} as Record<string, IconChange[]>);
  
  Object.entries(groupedChanges).forEach(([category, categoryChanges]) => {
    description += `### ${category} (${categoryChanges.length})\n\n`;
    categoryChanges.forEach(change => {
      description += `- **${change.name}**\n`;
      description += `  - Path: \`public/icons/${category}/${change.name}.png\`\n`;
    });
    description += `\n`;
  });
  
  description += `\n---\n\n`;
  description += `Generated by Icon Editor\n`;
  description += `Timestamp: ${new Date().toISOString()}\n`;
  
  return description;
}

/**
 * Create a commit message for icon changes
 * 
 * @param changes - Array of icon changes to document
 * @returns Formatted commit message with summary and details
 */
export function generateCommitMessage(changes: IconChange[]): string {
  const summary = `Update ${changes.length} icon(s) via Icon Editor`;
  
  const details = changes.map(change => 
    `- ${change.category}/${change.name}`
  ).join('\n');
  
  return `${summary}\n\n${details}`;
}
